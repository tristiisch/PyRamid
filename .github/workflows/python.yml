name: Python CI

on:
  push:
    branches:
      - "*"
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'
    paths:
      - "src/**/*.py"
      - "requirements.txt"
      - ".dockerignore"
      - "entrypoint.sh"
      - "Dockerfile"
      - "docker-compose*.yml"
      - ".github/workflows/python.yml"
  pull_request:
    types: [opened, synchronize]
    branches:
      - "*"
    paths:
      - "src/**/*.py"
      - "tests/**/*.py"
      - "requirements.txt"
      - ".dockerignore"
      - "entrypoint.sh"
      - "Dockerfile"
      - "docker-compose*.yml"
      - ".github/workflows/python.yml"
  workflow_dispatch:

env:
    MODULE_NAME: "pyramid"
    SRC: "./src"
    TEST_DIR: "./tests"
    REGISTRY_IMAGE: ${{ vars.DOCKERHUB_USERNAME }}/${{ vars.DOCKERHUB_REPO_NAME }}
    REGISTRY_IMAGE_PRIVATE: ${{ vars.DOCKER_REGISTRY_PRIVATE_URL }}/${{ github.actor }}/${{ github.event.repository.name }}

jobs:

  compile:
    name: "Compile Python 3.11"
    runs-on: ubuntu-latest
    outputs:
      json: ${{ steps.version.outputs.json }}
      version: ${{ steps.version.outputs.version }}
      branch: ${{ steps.version.outputs.branch }}
      last_author: ${{ steps.version.outputs.last_author }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
            path: ~/.cache/pip
            key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
            restore-keys: |
              - ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
              - ${{ runner.os }}-pip

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Test compilation
        run: |
          python -m compileall ${{ env.SRC }}

      - name: Save version
        run: |
          set -eu
          FULL_JSON=$(python ${{ env.SRC }} --version)
          echo "json=$(echo $FULL_JSON | jq -c)" >> $GITHUB_OUTPUT
          echo "version=$(echo $FULL_JSON | jq -r '.version')" >> $GITHUB_OUTPUT
          echo "commit_id=$(echo $FULL_JSON | jq -r '.git_info.commit_id')" >> $GITHUB_OUTPUT
          echo "branch=$(echo $FULL_JSON | jq -r '.git_info.branch')" >> $GITHUB_OUTPUT
          echo "last_author=$(echo $FULL_JSON | jq -r '.git_info.last_author')" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
        id: version

  unit_test:
    name: "Unit tests"
    needs: compile
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
            clean: false

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python_test-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            - ${{ runner.os }}-python_test-${{ hashFiles('**/requirements.txt') }}
            - ${{ runner.os }}-python_test-${{ hashFiles('**/requirements.txt') }}
            - ${{ runner.os }}-python

      - name: Install dependencies
        run: |
          set -eu
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Install project for tests
        run: |
          set -eu
          pip install pytest-cov
          pip install -e .

      - name: Units tests
        env:
          DEEZER__ARL: ${{ secrets.CONFIG_DEEZER_ARL }}
        run: |
          set -eu
          pytest --cov=${{ env.MODULE_NAME }} ${{ env.TEST_DIR }}

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4.5.0
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          slug: tristiisch/PyRamid

  unit_test_compatibility:
    name: "Envs unit tests"
    needs: unit_test
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version:
          - "3.8"
          - "3.9"
          - "3.10"
          - "3.12"
        platform:
          - linux/amd64
          - linux/arm64/v8
    continue-on-error: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
            path: ~/.cache/pip
            key: ${{ runner.os }}-python_test_${{ matrix.python-version }}_${{ matrix.platform }}-${{ hashFiles('**/requirements.txt') }}
            restore-keys: |
              - ${{ runner.os }}-python_test_${{ matrix.python-version }}_${{ matrix.platform }}
              - ${{ runner.os }}-python_test_${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          set -eu
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Install project for tests
        run: |
          set -eu
          pip install pytest-cov
          pip install -e .

      - name: Units tests
        env:
          DEEZER__ARL: ${{ secrets.CONFIG_DEEZER_ARL }}
        run: |
            pytest --cov=${{ env.MODULE_NAME }} ${{ env.TEST_DIR }}

  version_compatibility:
    name: "Envs compatibility"
    needs: compile
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version:
          - "3.8"
          - "3.9"
          - "3.10"
          - "3.12"
        platform:
          - linux/amd64
          - linux/arm64/v8
    continue-on-error: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: "${{ matrix.python-version }}"

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
            path: ~/.cache/pip
            key: ${{ runner.os }}-python_${{ matrix.python-version }}_${{ matrix.platform }}-${{ hashFiles('**/requirements.txt') }}
            restore-keys: |
              - ${{ runner.os }}-python_${{ matrix.python-version }}_${{ matrix.platform }}
              - ${{ runner.os }}-python_${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          set -eu
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Test compilation
        run: |
          python -m compileall ${{ env.SRC }}

  info:
    name: "Build information"
    needs: ["compile"]
    runs-on: ubuntu-latest
    outputs:
        environment: ${{ steps.environment.outputs.git_environment }}
        docker_tag: ${{ steps.environment.outputs.docker_tag }}
        commit_id: ${{ steps.environment.outputs.commit_id }}
        last_release_ref: ${{ steps.last_release.outputs.last_release_ref }}
        changelog: ${{ steps.changelog.outputs.changelog }}
    if: github.event_name == 'push'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 100

      - name: Get tags
        run: git fetch --tags origin

      - name: Define build variables
        id: environment
        uses: actions/github-script@v7
        with:
          script: |
            const refType = context.ref_type;
            const ref = context.ref;
            const sha = context.sha;

            let dockerTag;
            let gitEnvironment;

            if (refType === 'tag') {
              dockerTag = 'latest';
              gitEnvironment = 'production';
            } else if (ref === 'refs/heads/main') {
              dockerTag = 'pre-prod';
              gitEnvironment = 'pre-production';
            } else {
              dockerTag = 'dev';
              gitEnvironment = 'development';
            }
            const shortSha = sha.slice(0, 7);

            return { docker_tag: dockerTag, git_environment: gitEnvironment, commit_id: shortSha };

      - name: Get Github last release name
        id: last_release
        uses: actions/github-script@v7
        with:
          script: |
            const latestRelease = await github.rest.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            return { last_release_ref: latestRelease.data.tag_name };
  
      - name: Generate Changelog
        id: changelog
        uses: actions/github-script@v7
        with:
          script: |
            const lastRelease = '${{ steps.last_release.outputs.last_release_ref }}';
            const currentSha = context.sha;

            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              per_page: 100,
            });

            const mergedPulls = pulls.data.filter(pr => 
              pr.merged_at && 
              pr.merge_commit_sha >= lastRelease && 
              pr.merge_commit_sha <= currentSha
            );

            let changes = "## What's Changed";
            let contributorsNames = new Set();

            mergedPulls.forEach(pr => {
              changes += `* ${pr.title} ${pr.html_url}\n`;
              contributorsNames.add(pr.user.login);
            });

            let contributors = `### Contributors
            Thanks to @${Array.from(contributorsNames).join(', ')}.\n`;

            const fullChangelog = `**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${lastRelease}...${currentSha}`;
            const changelog = changes + '\n\n' + (contributorsNames.size ? contributors + '\n\n' : '') + fullChangelog;

            return { changelog: changelog };
    
      - name: Output Changelog
        run: echo "${{ steps.changelog.outputs.changelog }}"

      - name: Get Github commit messages
        id: commit_messages
        run: |
          set -eu
          COMMIT_MESSAGES=$(git log ${{ steps.last_release.outputs.last_release_ref }}..${{ github.sha }} --oneline --no-merges | sed 's/^/* /' | sed "s/\n/\\\\n/g")
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "commit_messages<<$EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Full Changelog**: https://github.com/tristiisch/PyRamid/compare/0.6.3-c6d1449...0.6.4" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT

  docker_image_build:
    name: "Build Docker Images"
    needs: ["compile", "info"]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    strategy:
      fail-fast: false
      matrix:
        platform:
          - linux/amd64
          - linux/arm64

    steps:
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set git info
        run: |
          echo '${{ needs.compile.outputs.json }}' | jq -r '.git_info' > git_info.json

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker image Build
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: mode=max
          build-args: |
            VERSION=${{ needs.compile.outputs.version }}
            GIT_COMMIT_ID=${{ needs.info.outputs.commit_id }}
            GIT_BRANCH=${{ needs.compile.outputs.branch }}
            GIT_LAST_AUTHOR=${{ needs.compile.outputs.last_author }}
          outputs: type=image,name=${{ env.REGISTRY_IMAGE }},push-by-digest=true,name-canonical=true,push=true

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  docker_image_push:
    name: "Push Docker Images"
    runs-on: ubuntu-latest
    needs: ["compile", "unit_test", "info", "docker_image_build"]

    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}
          tags: |
            type=raw,value=${{ needs.info.outputs.commit_id }},enable=${{ needs.info.outputs.docker_tag == 'latest' }}
            type=raw,value=${{ needs.info.outputs.docker_tag }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") $(printf '${{ env.REGISTRY_IMAGE }}@sha256:%s ' *)

  docker_image_push_private:
    name: "Push Privates Docker Images"
    runs-on: ubuntu-latest
    needs: ["compile", "unit_test", "info", "docker_image_build"]

    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Github Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY_PRIVATE_URL }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE_PRIVATE }}
          tags: |
            type=ref,event=branch
            type=raw,value=${{ needs.compile.outputs.version }}-${{ needs.info.outputs.commit_id }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") $(printf '${{ env.REGISTRY_IMAGE }}@sha256:%s ' *)

  docker_swarm_deploy:
    name: "Deploy v${{ needs.compile.outputs.version }} to ${{ needs.info.outputs.environment }}"
    needs: ["compile", "info", "docker_image_push"]
    runs-on: ubuntu-latest
    environment: ${{ needs.info.outputs.environment }}
    if: github.event_name == 'push' && (github.ref_type == 'tag' && needs.info.outputs.docker_tag == 'latest') || (github.ref_type == 'branch' && needs.info.outputs.docker_tag != 'latest')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Docker Swarm Update
        uses: tristiisch/docker-stack-deployment@master
        with:
          deployment_mode: docker-swarm
          remote_docker_host: ${{ secrets.MANAGER_HOST }}
          remote_docker_username: ${{ secrets.MANAGER_TO_USER }}
          ssh_private_key: ${{ secrets.MANAGER_TO_SSH_PRIVATE_KEY }}
          ssh_public_key: ${{ secrets.MANAGER_SSH_PUBLIC_KEY }}
          stack_file_path: ${{ vars.DOCKER_COMPOSE_FILENAME }}
          stack_name: ${{ vars.DOCKER_STACK_NAME }}
          secrets: ${{ vars.DOCKER_COMPOSE_SERVICE}} ${{ vars.DOCKER_STACK_NAME }} DISCORD__TOKEN ${{ secrets.CONFIG_DISCORD_TOKEN }} DEEZER__ARL ${{ secrets.CONFIG_DEEZER_ARL }} SPOTIFY__CLIENT_ID ${{ secrets.CONFIG_SPOTIFY_CLIENT_ID }} SPOTIFY__CLIENT_SECRET ${{ secrets.CONFIG_SPOTIFY_CLIENT_SECRET }} 

  release_publish:
    name: "Publish release"
    needs: ["compile", "info", "docker_image_push"]
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag' && github.event_name == 'push' && needs.info.outputs.docker_tag == 'latest'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update Release v${{ needs.compile.outputs.version }}
        run: |
          set -eu
          cat << $EOF | gh release edit "${{ github.ref_name }}" \
            --title "Release v${{ needs.compile.outputs.version }}" \
            --draft=false \
            --prerelease=false \
            --note-files -
          The latest version of the Discord bot PyRamid#6882 has been successfully deployed.
          To start using this updated version, please follow the instructions provided at [PyRamid Usage Guide](https://github.com/tristiisch/PyRamid/#usage).

          ${{ needs.info.outputs.changelog }}

          ## Docker
          This version is now accessible through various Docker images. Each image creation corresponds to a unique snapshot of this version, while updating the image corresponds to using an updated Docker image tag.
        
          ### Images Uniques
          *  `${{ env.REGISTRY_IMAGE_PRIVATE }}:${{ needs.compile.outputs.version }}-${{ needs.info.outputs.commit_id }}`

          ### Images Updates
          * `${{ env.REGISTRY_IMAGE }}:${{ needs.info.outputs.docker_tag }}`
          * `${{ env.REGISTRY_IMAGE }}:${{ needs.compile.outputs.version }}`
          $EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
